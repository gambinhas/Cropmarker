Cropmarker WebApp — Description & Operating Notes
Date: 2026-01-13

1) Objective (what this is)
Cropmarker Web is a lightweight web application for crowdsourced annotation of aerial imagery for archaeological cropmark detection.

The goal is to:
- Collect consistent per-user classifications: No Mark (0), Cropmark (1), Unclear (2)
- For positive/uncertain cases, collect a rough drawing of where the mark is visible
- Include hidden intra-annotator quality control (QC) via random duplicates
- Support low digital literacy annotators with a simple, guided workflow


2) What annotators do (workflow)
High-level flow:
1) Sign in with a username (no password).
2) If it is a new username, select an expertise level (0/1/3/5).
3) Show a “Before you start” intro page with a summary image and a “Start annotating” button.
4) Annotate images one by one:
   - Choose a label (No Mark / Cropmark / Unclear)
   - If Cropmark or Unclear, draw a rough outline on the image
   - Save & Next
5) Continue until all assigned tasks are completed.

Notes:
- Annotators do NOT see task order metadata and do NOT see which items are QC duplicates.
- Some images appear more than once (QC duplicates). Annotators should treat each image independently.


3) What data is stored (and how)
Storage backend:
- SQLite database (persistent file) via SQLAlchemy

Core data model (conceptual):
- Task: a base image record imported from the dataset (site, filename, rel_path, unique_id)
- UserTask: a per-user instance of a Task (supports duplicates and per-user random ordering)
- Annotation: the saved work for a given user on a given UserTask

Important design choice:
- UserTask exists because duplicates must not collide. A QC duplicate is represented as a separate UserTask instance even if it points to the same base Task.

What an Annotation contains:
- cropmark: 0/1/2
- drawing_json: serialized stroke list (JSON string)
- brightness, contrast (UI adjustments; optional)


4) How saving works
- “Save & Next” sends the selected label and the drawing (if any) to the backend.
- The backend inserts/updates a single Annotation row for that (user_id, user_task_id).
- If the annotator returns to a previously seen task, the UI is hydrated from the existing Annotation.

Workflow rules enforced in the UI:
- No Mark can be saved without drawing.
- Cropmark / Unclear require drawing.


5) Random order + QC duplicates
Per user, the app creates:
- 381 original tasks
- 39 QC duplicates
Total per user: 420

Generation details:
- Original tasks are imported once from the dataset.
- For each user, the app randomly selects QC_DUPLICATES_PER_USER base tasks to duplicate.
- Original and duplicated items are then shuffled into a per-user random order.

QC fields:
- qc_reference: stored on UserTask; points to the original task unique_id for duplicates


6) Image dataset structure
Images are served as:
- /images/<site>/<filename>.jpg

Expected dataset folder layout:
image_dataset/
  <SITE_NAME>/
    *.jpg


7) Admin / results / export
Annotators:
- Do not have any download/export UI.

Admin export:
- Export is done via the admin CLI (manage.py), generating per-user XLSX files in the requested format:
  cropmarks_<username>_<expertise_score>.xlsx

XLSX columns:
- Site
- Date (parsed from filename like “aug2021” -> “08/2021” when possible)
- Cropmark
- Image (filename)
- Saved (“S” if an annotation exists)
- Drawing (drawing_json)
- QC_Reference
- UniqueID (base task unique_id)
- Order (user display_order)


8) Deployment notes (Render)
Recommended production setup:
- Use a persistent disk mounted at /var/data
- Store:
  - DB at /var/data/webapp.sqlite3
  - dataset at /var/data/image_dataset

Environment variables:
- CROPMARKER_SECRET_KEY: session secret
- CROPMARKER_DB_PATH: path to SQLite DB
- CROPMARKER_DATASET_ROOT: path to the dataset root

Bootstrap steps on Render:
1) Ensure dataset exists at CROPMARKER_DATASET_ROOT with 381 JPG images.
2) Import tasks into the DB:
   python -m webapp.manage --db /var/data/webapp.sqlite3 --dataset-root /var/data/image_dataset import-tasks
3) Create an admin user (optional):
   python -m webapp.manage --db /var/data/webapp.sqlite3 create-user --username admin --admin


9) Files of interest (code map)
- webapp/app.py
  Main FastAPI application; routes for login/new user/intro/tasks/annotation.
- webapp/manage.py
  Admin CLI for init/import/export.
- webapp/templates/
  HTML templates (login, new_user, intro, annotate, done).
- webapp/static/app.css
  Styling.
- resources/cropmark.png
  Intro summary image.


10) Operational checklist
- Confirm dataset path contains 381 JPGs.
- Confirm tasks imported (381 base tasks).
- Confirm new users can create 420 user tasks (381 + 39 QC duplicates).
- Confirm annotations persist across refresh and across sessions.
- Use CLI export-xlsx to generate admin deliverables.
